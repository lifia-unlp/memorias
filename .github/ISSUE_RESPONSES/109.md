### Root cause

The `AdministrationComponent>>setMissingSlugs` bulk action loops over every researcher, project, thesis, and reference and calls `self session save:` on them, even when their metadata is already correct.

 That ends up delegating to `LifiometroRepository>>save:onBehalfOf:`, which always stamps the record with the current timestamp and acting user before persisting it.

 When the save happens on detached in-memory copies that no longer carry their Voyage identity, Voyage inserts new documents instead of updating the originals. The duplicates therefore share identical domain attributes (same e-mail, names, etc.) and, critically, share the exact `lastEditedOn` instant and `lastEditedBy` user that came from the administrative run.



:::task-stub{title="Batch identify and clean duplicate Lifian documents produced by setMissingSlugs"}
1. Open a playground and load all researchers with `all := Lifian selectAll.` Group them by a stable key such as institutional e-mail (falling back to the full name when the e-mail is missing) and filter groups that have more than one entry *and* share the same `lastEditedOn` timestamp, which pinpoints the records created by the `setMissingSlugs` run. A helper like `suspectGroups := (all groupedBy: [:each | each institutionalEmail ifNil: [each fullName]]) values select: [:group | group size > 1 and: [group asSet collect: #lastEditedOn size = 1]].` will give you just the problematic clusters.



2. For each suspect group, choose the canonical document—typically the one whose slug lacks the numeric suffix or whose `voyageId` is smallest—`canonical := (group asSortedCollection: [:a :b | a voyageId < b voyageId]) first.` Keep the canonical in memory and build a dictionary that maps every duplicate to this survivor so you can rewrite references deterministically.


3. Traverse every Voyage root that can point at researchers (`Project selectAll`, `Scholarship selectAll`, `Thesis selectAll`, `BibtexReference selectAll`, and the researcher collection itself) and replace any occurrence of a duplicate in `relatedLifians` with the canonical object, e.g., `each relatedLifians collect: [:lifian | replacements at: lifian ifAbsent: [lifian]]; yourself; save.` This relies on the shared `relatedLifians` accessor provided by `LifiaLogEntry`, so the same replacement logic works across all entry types.


4. Once all references have been normalized, delete the orphan duplicates in bulk (`replacements keysDo: [:duplicate | duplicate delete]`) and finally clear the repository’s slug cache with `LifiometroRepository singleton slugsInUse removeAll.` This prevents the recycled slugs from remaining marked as taken and ensures future saves reuse the expected slug for the canonical record.


5. As a verification pass, re-run the grouping from step 1 and assert that no suspect groups remain. Optionally, spot-check a few affected researchers through the UI to confirm their report URLs resolve via slug (or fallback `voyageId`) and no duplicate cards remain.


:::
